Exercise 1 - VRF Oracle

For Part A, I deployed the DirectFundingConsumer contract on the Sepolia testnet at the address 0xd8c4c25b8Eb57eDe14Ad7303D7EeD371cF1Ec8D7. After deploying the contract, I funded it with over 3 LINK tokens so that it could pay the Chainlink VRF fee. I then sent a transaction that called the function requestRandomWords with the parameter “false” (meaning the fee is paid in LINK rather than ETH). This call initiated the request for random numbers, and as a result, two events were emitted on Etherscan.

The first event, called RequestSent (or RequestSet), was emitted immediately when the requestRandomWords function was called. This event returns two fields. The first field is the requestId, which is a unique identifier used to track the request and later match it with the VRF response. The second field is numWords, which indicates how many random words were requested. Later, after the Chainlink VRF provided a response, a second event called RequestFulfilled was emitted. Although the Solidity event signature shows three arguments, when the log data is broken down there are effectively six pieces of information. These include the requestId (matching the original request), the length of the returned randomWords array (which in this case is 2), the first random word (randomWords[0]), the second random word (randomWords[1]), and the amount of LINK (expressed in wei) that was paid to fulfill the request. There is also an additional field—an offset or pointer for the dynamic array—that can be seen in the raw log data. The key information from RequestFulfilled is the requestId, the two random numbers, and the LINK payment.

The two random numbers generated by the oracle, as seen in the RequestFulfilled event (block #7659710, transaction hash 0xa18e0fa09a961ed3272d5cd29815c258848b27af9118066db656334caa1df11a), are:
• 0x05d4dd12954423e388b83fc892cfd7a74d007db28372394e54e6a006a1b97cc2  
• 0xfea5232913d58893aa347bf14cc9081dadd6286d0893c54bc7f21728b7257dce

I have included two screenshots in the repository. One screenshot shows the events with hexadecimal values, and the other shows them with number values.

For Part B, the updated Coinflip contract no longer relies on a predictable seed phrase to generate randomness. Instead, it uses a dedicated VRF consumer contract (DirectFundingConsumer) to obtain cryptographically secure random numbers from Chainlink VRF. When a player submits three coinflip guesses (each either 0 or 1), the contract stores the bets and calls the VRF consumer’s requestRandomWords function with a parameter indicating that three random words should be returned. The contract maps the resulting requestId to the player’s address. Once the VRF oracle fulfills the request, the determineFlip function retrieves the random words and converts each one into a coinflip outcome by taking its remainder modulo 2 (with even numbers treated as 0 and odd numbers as 1). These outcomes are then compared with the player’s stored guesses to determine if the player wins. This method follows best practices for secure on-chain randomness and uses access control via OpenZeppelin’s Ownable module. The changes include deploying an instance of the DirectFundingConsumer contract from the Coinflip contract’s constructor and updating the functions to use requestRandomWords (with “true” in this case to indicate three words) along with getRequestStatus to retrieve the outcome, rather than using a deterministic seed.

For Part C, the direct funding and subscription methods differ mainly in how they handle payment for VRF randomness. In the direct funding method, each consumer contract must hold and transfer its own LINK (or native) tokens at the time of the request, making it suitable for applications with infrequent or one-off randomness requests. In contrast, the subscription method uses a single, pre-funded subscription account that supports multiple consumer contracts; requests from any linked contract are billed against this shared pool after the randomness is fulfilled. This subscription approach is more efficient and scalable for applications that require frequent or batch randomness requests.

This answer, along with the two screenshots of the events from Etherscan, is included in the same GitHub repository.